[{"id":"ca5952bfad3c73b70d9d4e09ee5807a8","title":"CS61A","content":"Lab00 doctest“ &gt;&gt;&gt; “ leads a doctest in python3, which provides a way to easily check if a proj runs correctly, can only be used in docstring ( a type of tips)\n&#39;&#39;&#39; #leads a docstring\n&gt;&gt;&gt;pythoninput\nresult\n&#39;&#39;&#39;\n\npython tools can automatically check if the pythoninput runs correctly with an expected result. Just as use test examples in terminal to check out. \nFundation1. Expressionprimitive expression\ncall expression\nEverthing can stand for a specific number or a function or anything like that is an expression\nplus? add? multiple\n&gt;&gt;&gt; from operator import add, mul\n&gt;&gt;&gt; add( a, b)\n\nOperator is the expresstion before (), in () are Operands divided by ,\nin python, expressions can be defined apart\na, b &#x3D; num_a, num_b\n\nthen a and b can have their own value of num_a  and num_b\n2. user defined functionsdefine a user preferred function with “ &#x3D; “\nmax\n&lt;built-in function &quot;max&quot;&gt;\nf &#x3D; max\ng &#x3D; f\n\nthen f and g can be used just the same as “max” function.\ndefine your own function\ndef f(x):\n    ...\n\nthen we got a function of f(x) that do some operation with x\nif in a function there’re some other variables, it would keep in sync when the variables change\na &#x3D; 10\ndef f():\n    return a*2\n\nf() &#x3D; 20\na &#x3D; 5\nf() &#x3D; 10\n\n3. environment diagramwhen we call user_defined functions:\nProcedure for calling&#x2F;applying user-defined functions (version 1):\n\nAdd a local frame, forming a new environment\n\nBInd the function’s formal parameters to its arguments in that frame\n\nExecute the body of the function in that new environment!\n\n\n4. Looking up names in environmentevery expression is evaluated in the context of an environment.\nSo far, the current environment is either the global frame alone or a local frame, followed by the global frame.\nMOST important things of all dayAn environment is a sequence of frames.\nA name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.\nFunctionsuse “”” to lead a function’s explanation to get it accessable to user.\ndef func(x, y)\n&quot;&quot;&quot;\nTo get x*y\n&quot;&quot;&quot;\n\treturn x*y\n\nUse help(func) to see the explanation in interactive interface of python3.\nUse command line characters python3 -i a.py to run a.py in interactive terminal interface.\nUse command line characters python3 -m doctest a.py to run a.py with the samples from doctest.\nUse assert to check function’s assert range\ndef func(x, y)\n&quot;&quot;&quot;\nget x*y\n&quot;&quot;&quot;\n\tassert x &gt; 0, &#39;x must be postive&#39;\n\treturn x*y\n\nWhat assert leads should be the correct situation, means assert check if “x&gt;0” is true, if not it prints the context in ‘ ‘\nshort circuit in logical operator:a and b: if a is true, just return b; if a is false, just return a.\na or b: if a is true, just return a; if a is false, just return b.\ncalculation operators have higher running level than logic operator.\nFunctions inputpython function can  accept a name to simply input another function\ndef square(x):\n    return x * x\ndef cube(x):\n    return x * x * x\ndef cal(x, method):\n    return method(x);\n\n\n\nLambda expressionLambda expression is a efficient way to assign hidden functions.\n#lambda expression version of assignment of add\nadd &#x3D; lambda x, y: x + y\n&gt;&gt;&gt; add(1, 2)\n&gt;&gt;&gt; 3\n#normal defination of add\ndef add(x, y):\n    return x+y\n\nLambda expression can also have an empty parameter:\nc &#x3D; lambda: 88\n&gt;&gt;&gt; c\n&gt;&gt;&gt; &lt;lambda function&gt;\n&gt;&gt;&gt; c()\n&gt;&gt;&gt; 88\n\nFunction CurryingDivide a function’s input parameter into singles.\nfrom operator &#x3D; add\n&gt;&gt;&gt; add(1, 2)\n&gt;&gt;&gt; 3\n#lambda method to get currying function\ncurrAdd &#x3D; lambda x: lambda y: x + y\n&gt;&gt;&gt; currAdd(1, 2)\n&gt;&gt;&gt; Wrong\n&gt;&gt;&gt; currAdd(1)(2)\n&gt;&gt;&gt; 3\n#defination method to get currying function\ndef curr2(f):\n    def g(x):\n        def h(y):\n            return f(x,y)\n        return h\n    return g\ncurrAdd &#x3D; curr2(add)\n&gt;&gt;&gt; currAdd(1)(2)\n&gt;&gt;&gt; 3\n\nThe defination method of currying can be seemed as using g and h to get x and y singly passed into currFunc.\nArranging inputting parameters functionIn python we can use *type to get arranging inputting parameters:\ndef func(*args):\n    for i in args:\n        print(i)\n\n&gt;&gt;&gt; func(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)\n&gt;&gt;&gt; a\n&gt;&gt;&gt; b\n&gt;&gt;&gt; c\n&gt;&gt;&gt; d\n\n\n\nClosure  functions: TO BE COMPLETEDKeyword try can be used to test whether codes can run correctly in advance.\nRecursionA function is called recursive if it calls itself in function body.\nThe recursion is like a stack, which obeys the principle of “First in, Last out”. So when we are backtracking a recursive function’s level, it would turn out one by one.\ndef level(n):\n  print(n)\n  if n &gt;&#x3D; 1:\n  \treturn(n&#x2F;&#x2F;2)\n  else:\n    return n\n&#39;&#39;&#39;\n&gt;&gt;&gt;level(8)\n&gt;&gt;&gt;8\n&gt;&gt;&gt;4\n&gt;&gt;&gt;2\n&gt;&gt;&gt;1\n&gt;&gt;&gt;0.5\n&gt;&gt;&gt;0.5\t\t&#x2F;&#x2F;this is the final return value of level(8)\n&#39;&#39;&#39;\n\nFragment in RecursionEvery time the function is called, a fragment is created and used to process the very level of recursion. After finnal breakpoint of recursion, the levels will turn out one by one, obeying “First in, Last out”.\nMutual RecursionTwo or more functions calling one another in recursion is called mutual recursion.\nTree RecursionIf a function has called itself more than one time in different situations, it is called a tree recursion.\ndef count_partitions(n, m):\n        &quot;&quot;&quot;Count the ways to partition n using parts up to m.&quot;&quot;&quot;\n        if n &#x3D;&#x3D; 0:\n            return 1\n        elif n &lt; 0:\n            return 0\n        elif m &#x3D;&#x3D; 0:\n            return 0\n        else:\n            return count_partitions(n-m, m) + count_partitions(n, m-1)\n\nData AbstractionNumeric TypesIn python, there are some built-in data type class, we can use type( ) to check this.\n&gt;&gt;&gt;type(2)\n&lt;class &#39;int&#39;&gt;\n&gt;&gt;&gt;type(1.5)\n&lt;class &#39;float&#39;&gt;\n&gt;&gt;&gt;type(1+1j)\n&lt;class &#39;complex&#39;&gt;\n\nAs is shown above, python has 3 basical classes of numbers:\n​\t‘int’ for intergers, ‘float’ for float point numbers, ‘complex’ for complex numbers.\nThese number types are described as class, and all of the numbers are instances of a very class. And in the built-in classes, there’re some defined operations for the class. For example, add and minus.\nSequencesA sequence is an ordered collection of values. The sequence is a powerful, fundamental abstraction in computer science. Sequences are not instances of a particular built-in type or abstract data representation, but instead a collection of behaviors that are shared among several different types of data. That is, there are many kinds of sequences, but they all share common behavior. In particular,\nLength. A sequence has a finite length. An empty sequence has length 0.\nElement selection. A sequence has an element corresponding to any non-negative integer index less than its length, starting at 0 for the first element.\nPython includes several native data types that are sequences, the most important of which is the list.\nListIn list, use Len() to get its length. It’s subscripts begin with 0 and end with Len(list)-1.\nTwo or more lists can be added head after tail. So a list can be multiplied with an integer, which means spread it by a specific time.\n&gt;&gt;&gt;list &#x3D; [1, 2, 3, 4, 5]\n&gt;&gt;&gt;len(list)\n5\n&gt;&gt;&gt;list[3]\n4\n&gt;&gt;&gt;2*list\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n&gt;&gt;&gt;addition &#x3D; [6, 7, 8]\n&gt;&gt;&gt;list + addition\n[1, 2, 3, 4, 5, 6, 7, 8]\n\nSequence IterationFor sequences, python has a for keyword to simply iterate them. A commonly used situation is shown as below\n&gt;&gt;&gt;list &#x3D; [1, 2, 3, 4, 5]\n&gt;&gt;&gt;for i in list:\n&gt;&gt;&gt;\tprint(i)\n1\n2\n3\n4\n5\n\nA for statement consists of a single clause with the form:\nfor &lt;name&gt; in &lt;expression&gt;:\n    &lt;suite&gt;\n\nA for statement is executed by the following procedure:\n\nEvaluate the header &lt;expression&gt;, which must yield an iterable value.\nFor each element value in that iterable value, in order:\nBind &lt;name&gt; to that value in the current frame.\nExecute the &lt;suite&gt;.\n\n\n\nSpecifically, for-loop can unpack a sequence automatically, for example, we’re given a list of lists\n&gt;&gt;&gt;pairs &#x3D; [[1,2], [2,3], [3,4], [5,4]]\n\nWe can simply use for-loop to invoking the elements of the list in pairs:\n&gt;&gt;&gt;for x, y in pairs:y\n&gt;&gt;&gt;\tif x &gt; y:\n&gt;&gt;&gt;\t\tprint(x, &#39;,&#39;, y)\n5, 4\n\nRanges. A range is another built-in type of sequence in Python, which represents a range of integers. Ranges are created with range, which takes two integer arguments: the first number and one beyond the last number in the desired range.\n&gt;&gt;&gt;list(range(5, 8))\n[5, 6, 7]\n\nIf the first number in range is omitted, it will be 0 by default.\nSometimes, we shall use _ as the name of iterator. It has a conventional meaning among programmers that indicates this value won’t be used in any future expression.\nSequence ProcessingList Comprehensions. Many sequence processing operations can be expressed by evaluating a fixed expression for each element in a sequence and collecting the resulting values in a result sequence. In Python, a list comprehension is an expression that performs such a computation.\n&gt;&gt;&gt; odds &#x3D; [1, 3, 5, 7, 9]\n&gt;&gt;&gt; [x+1 for x in odds]\n[2, 4, 6, 8, 10]\n\nThe general form of a list comprehension is:\n[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;]\n\nTo evaluate a list comprehension, Python evaluates the &lt;sequence expression&gt;, which must return an iterable value. Then, for each element in order, the element value is bound to &lt;name&gt;, the filter expression is evaluated, and if it yields a true value, the map expression is evaluated. The values of the map expression are collected into a list.\nSequence AbstractionMembership. A value can be tested for membership in a sequence. Python has two operators in and not in that evaluate to True or False depending on whether an element appears in a sequence.\n&gt;&gt;&gt; digits\n[1, 8, 2, 8]\n&gt;&gt;&gt; 2 in digits\nTrue\n&gt;&gt;&gt; 1828 not in digits\nTrue\n\nSlicing. Sequences contain smaller sequences within them. A slice of a sequence is any contiguous span of the original sequence, designated by a pair of integers. As with the range constructor, the first integer indicates the starting index of the slice and the second indicates one beyond the ending index.\nIn Python, sequence slicing is expressed similarly to element selection, using square brackets. A colon separates the starting and ending indices. Any bound that is omitted is assumed to be an extreme value: 0 for the starting index, and the length of the sequence for the ending index.\n&gt;&gt;&gt; digits[0:2]\n[1, 8]\n&gt;&gt;&gt; digits[1:]\n[8, 2, 8]\n\nNegative numbers are also allowed in slicing operation. They means counting from the tail of the list.\n&gt;&gt;&gt; digits[0:-1]\n[1, 8, 2]\n\nStringsIn python, strings have a constructor str\n&gt;&gt;&gt;a &#x3D; 1\n&gt;&gt;&gt;type(str(a))\n&lt;class &#39;string&#39;&gt;\n\nString can be treated and operated as a sequence of characters, which means we can use subscripts to invoking its components or us len() to get its length.\n&gt;&gt;&gt; city &#x3D; &#39;Berkeley&#39;\n&gt;&gt;&gt; len(city)\n8\n&gt;&gt;&gt; city[3]\n&#39;k&#39;\n\nStrings can also be directly added together, presenting a result of head-after-tail of the addends. And the multipling is the same as sequences’.\n&gt;&gt;&gt; str1 &#x3D; &#39;ABC&#39;\n&gt;&gt;&gt; str2 &#x3D; &#39;DEF&#39;\n&gt;&gt;&gt; str1 + str2\n&#39;ABCDEF&#39;\n\nTreeThe tree is a fundamental data abstraction that imposes regularity on how hierarchical values are structured and manipulated.\nA tree has a root label and a sequence of branches. Each branch of a tree is a tree. A tree with no branches is called a leaf. Any tree contained within a tree is called a sub-tree of that tree (such as a branch of a branch). The root of each sub-tree of a tree is called a node in that tree.\nWe can implement a tree in python in following format\n&gt;&gt;&gt; def tree(root_label, branches&#x3D;[]):\n        for branch in branches:\n            assert is_tree(branch), &#39;branches must be trees&#39;\n        return [root_label] + list(branches)\n&gt;&gt;&gt; def label(tree):\n        return tree[0]\n&gt;&gt;&gt; def branches(tree):\n        return tree[1:]\n\nA tree is well-formed only if it has a root label and all branches are also trees. The is_tree function is applied in the tree constructor to verify that all branches are well-formed.\n&gt;&gt;&gt; def is_tree(tree):\n        if type(tree) !&#x3D; list or len(tree) &lt; 1:\n            return False\n        for branch in branches(tree):\n            if not is_tree(branch):\n                return False\n        return True\n\nThe is_leaf function checks whether or not a tree has branches.\n&gt;&gt;&gt; def is_leaf(tree):\n        return not branches(tree)\n\nTIPSfrom os import *\ntry:\n    import pandas\nexcept ImportError:\n    system(&quot;pip install pandas&quot;)\n\nThis snippet can check if you have installed pandas. If you had, importing succeeds, otherwise it will run the except context.\n","slug":"CS61A","date":"2022-11-11T03:18:10.000Z","categories_index":"","tags_index":"","author_index":"Rostee Yantaz"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"This is a test post.I’m planning to move my notes on yuque onto my own site.\n","slug":"test","date":"2022-09-29T14:48:39.000Z","categories_index":"","tags_index":"test","author_index":"Rostee Yantaz"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to my page!\nJUST A TEST \n\nnice to see ya!","slug":"hello-world","date":"2022-09-24T12:16:56.774Z","categories_index":"","tags_index":"","author_index":"Rostee Yantaz"}]